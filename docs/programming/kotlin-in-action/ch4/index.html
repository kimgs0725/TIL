<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-programming/kotlin-in-action/ch4">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.18">
<link rel="alternate" type="application/rss+xml" href="/til/blog/rss.xml" title="Today I Learned RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/til/blog/atom.xml" title="Today I Learned Atom Feed"><title data-rh="true">4. 클래스, 객체, 인터페이스 | Today I Learned</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="http://wondsn.github.io/til/docs/programming/kotlin-in-action/ch4"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="4. 클래스, 객체, 인터페이스 | Today I Learned"><meta data-rh="true" name="description" content="1. 클래스 계층 정의"><meta data-rh="true" property="og:description" content="1. 클래스 계층 정의"><link data-rh="true" rel="icon" href="/til/img/favicon.ico"><link data-rh="true" rel="canonical" href="http://wondsn.github.io/til/docs/programming/kotlin-in-action/ch4"><link data-rh="true" rel="alternate" href="http://wondsn.github.io/til/docs/programming/kotlin-in-action/ch4" hreflang="en"><link data-rh="true" rel="alternate" href="http://wondsn.github.io/til/docs/programming/kotlin-in-action/ch4" hreflang="x-default"><link rel="stylesheet" href="/til/assets/css/styles.5627add0.css">
<link rel="preload" href="/til/assets/js/runtime~main.bfa5a1d6.js" as="script">
<link rel="preload" href="/til/assets/js/main.641e2650.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/til/"><b class="navbar__title">Wondsn TIL</b></a><a class="navbar__item navbar__link navbar__link--active" href="/til/docs/intro">Docs</a><a href="http://wondsn.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/wondsn" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_S7eR colorModeToggle_vKtC"><button class="clean-btn toggleButton_rCf9 toggleButtonDisabled_Pu9x" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_v35p"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_nQuB"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper"><div class="docPage_P2Lg"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_RiI4" type="button"></button><aside class="theme-doc-sidebar-container docSidebarContainer_rKC_"><div class="sidebar_RiAD"><nav class="menu thin-scrollbar menu_izAj"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/til/docs/intro">Welcome TIL</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/til/docs/blog/attach-image">Docusarus Ops Tip</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/til/docs/development/refactoring/ch0">development</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/til/docs/programming/kotlin-in-action/ch1">programming</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" tabindex="0" href="/til/docs/programming/kotlin-in-action/ch1">Kotlin In Action</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/programming/kotlin-in-action/ch1">1. 코틀린은 무엇이며, 왜 필요한가?</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/programming/kotlin-in-action/ch2">2. 코틀린 기초</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/programming/kotlin-in-action/ch3">3. 함수의 정의와 호출</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/til/docs/programming/kotlin-in-action/ch4">4. 클래스, 객체, 인터페이스</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/programming/kotlin-in-action/ch5">5. 람다로 프로그래밍</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/programming/kotlin-in-action/ch6">6. 코틀린 타입 시스템</a></li></ul></li></ul></li></ul></nav></div></aside><main class="docMainContainer_TCnq"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_DM6M"><div class="docItemContainer_vinB"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Xlws" aria-label="breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a class="breadcrumbs__link" href="/til/">🏠</a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><span class="breadcrumbs__link" itemprop="item name">programming</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><span class="breadcrumbs__link" itemprop="item name">Kotlin In Action</span><meta itemprop="position" content="2"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="item name">4. 클래스, 객체, 인터페이스</span><meta itemprop="position" content="3"></li></ul></nav><div class="tocCollapsible_jdIR theme-doc-toc-mobile tocMobile_TmEX"><button type="button" class="clean-btn tocCollapsibleButton_Fzxq">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>4. 클래스, 객체, 인터페이스</h1></header><h2 class="anchor anchorWithStickyNavbar_mojV" id="1-클래스-계층-정의">1. 클래스 계층 정의<a class="hash-link" href="#1-클래스-계층-정의" title="Direct link to heading">​</a></h2><ul><li>코틀린 가시성/접근 변경자는 자바와 비슷하지만 아무것도 지정하지 않는 경우 기본 가시성은 다름</li><li><code>sealed</code>는 클래스 상속을 제한</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="코틀린-인터페이스">코틀린 인터페이스<a class="hash-link" href="#코틀린-인터페이스" title="Direct link to heading">​</a></h3><ul><li>코틀린 인터페이스 안에 구현 메소드도 정의할 수 있음</li><li><code>interface</code>로 인터페이스 선언</li></ul><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx" style="color:#F8F8F2;background-color:#282A36"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">interface Clickable {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    fun click()</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">class Button: Clickable {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    override fun click() = println(&quot;I was clicked&quot;)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><ul><li>자바에선 <code>extends</code>, <code>implements</code> 키워드를 붙이지만, 코틀린은 콜론(:) 뒤에 인터페이스명을 적음</li><li>자바에서 <code>@Override</code> 애노테이션과 비슷한 <code>override</code> 변경자가 있음</li><li>인터페이스 메소드도 디폴트 구현할 수 있음</li></ul><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx" style="color:#F8F8F2;background-color:#282A36"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">interface Clickable {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    fun click()</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    fun showOff() = println(&quot;I&#x27;m clickable&quot;)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><ul><li>디폴트 메소드를 구현하려는 클래스에선 재정의 해도 되고, 디폴트 메소드를 이용해도 됨</li></ul><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx" style="color:#F8F8F2;background-color:#282A36"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">interface Focusable {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    fun setFocus(b: Boolean) =</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        println(&quot;I ${if (b) &quot;got&quot; else &quot;lost&quot;} focus.&quot;)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    fun showOff() = println(&quot;I&#x27;m focusable&quot;)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><ul><li>만약 <code>Clickable</code>와 <code>Focusable</code>을 구현한다면 어떻게 될까?<ul><li><code>showOff()</code> 메소드를 직접 구현하지 않으면 컴파일러가 어느 인터페이스 구현체를 선택할 지 몰라서 컴파일러 에러를 밷음</li><li>컴파일러는 하위 클래스에 두 메소드를 아우르는 구현을 강제화시킴</li></ul></li></ul><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx" style="color:#F8F8F2;background-color:#282A36"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">class Button: Clickable, Focusable {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    override fun click() = println(&quot;I was clicked&quot;)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    override fun showOff() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        super&lt;Clickable&gt;.showOff()  // 꺽쇠 괄호에 상위 타입을 지정하여 메소드를 호출할 수 있음</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        super&lt;Focusable&gt;.showOff()</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="open-final-abstract-변경자-기본적으로-final">open, final, abstract 변경자: 기본적으로 final<a class="hash-link" href="#open-final-abstract-변경자-기본적으로-final" title="Direct link to heading">​</a></h3><ul><li>Effective Java에선 <strong>상속을 위한 설계와 문서를 갖추거나, 그럴 수 없다면 상속을 금지하라</strong>라고 조언함</li><li>코틀린 클래스와 메소드도 기본적으로 <code>final</code><ul><li>상속을 허용하려면 클래스 앞에 <code>open</code> 변경자 붙여야 함</li></ul></li></ul><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx" style="color:#F8F8F2;background-color:#282A36"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">open class RichButton: Clickable {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  fun disable() {}        // 이 함수는 파이널. 하위 클래스가 오버라이드 X</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  open fun animate() {}   // 이 함수는 열려있음. 하위 클래스가 오버라이드 O</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  override fun click() {} // 오버라이드 함수. 하위 클래스가 오버라이드 O</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  // 만약 오버라이드 함수를 하위 클래스에서 오버라이드를 원치 않는다면 final을 붙임</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  final override fun click() {}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><ul><li><code>abstract</code> 클래스는 인스턴스화 X</li><li><code>abstract</code> 내 추상 멤버는 항상 open이 기본</li></ul><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx" style="color:#F8F8F2;background-color:#282A36"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">abstract class Animated {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  abstract fun animate()  // 추상 멤버는 구현 x, 하위 클래스에서 오버라이드 해야함</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  open fun stopAnimating() {} // 비추상 함수는 기본적으로 final. 오버라이드를 원한다면 open 붙임</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  fun animateTwice() {}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><table><thead><tr><th>변경자</th><th>이 변경자가 붙은 멤버</th><th>설명</th></tr></thead><tbody><tr><td>final</td><td>오버라이드 X</td><td>클래스 멤버의 기본 변경자</td></tr><tr><td>open</td><td>오버라이드 O</td><td>반드시 open을 명시해야 오버라이드 할 수 있음</td></tr><tr><td>abstract</td><td>반드시 오버라이드 해야함</td><td>추상 클래스 멤버에만 적용 가능. 추상 멤버는 구현 X</td></tr><tr><td>override</td><td>상위 클래스, 인스턴스의 멤버를 오버라이드</td><td>오버라이드 멤버는 기본적으로 open. 하위 클래스에 오버라이드를 원치 않으면 final 붙임</td></tr></tbody></table><h3 class="anchor anchorWithStickyNavbar_mojV" id="가시성-변경자-기본적으로-공개">가시성 변경자: 기본적으로 공개<a class="hash-link" href="#가시성-변경자-기본적으로-공개" title="Direct link to heading">​</a></h3><ul><li>기존 가시성 변경자는 <code>public</code></li><li>패키지 전용 가시성 변경자로 <code>internal</code>이 있음<ul><li>모듈 내부에서만 접근 가능</li></ul></li><li>최상위 선언에 대해 <code>private</code> 가시성을 허용<ul><li>비공개 기사성인 최상위 선언은 그 선언이 들어있는 파일 내부에서만 사용 가능</li></ul></li></ul><table><thead><tr><th>변경자</th><th>클래스 멤버</th><th>최상위 선언</th></tr></thead><tbody><tr><td>public(기본 가시성)</td><td>모든 곳에서 볼 수 있음</td><td>모든 곳에서 볼 수 있음</td></tr><tr><td>internal</td><td>같은 모듈 안에서만 볼 수 있음</td><td>같은 모듈 안에서만 볼 수 있음</td></tr><tr><td>protected</td><td>하위 클래스 안에서만 볼 수 있음</td><td>(최상위 선언에 적용할 수 없음)</td></tr><tr><td>private</td><td>같은 클래스 안에서만 볼 수 있음</td><td>같은 파일 안에사만 볼 수 있음</td></tr></tbody></table><h3 class="anchor anchorWithStickyNavbar_mojV" id="내부-클래스와-중첩된-클래스-기본적으로-중첩-클래스">내부 클래스와 중첩된 클래스: 기본적으로 중첩 클래스<a class="hash-link" href="#내부-클래스와-중첩된-클래스-기본적으로-중첩-클래스" title="Direct link to heading">​</a></h3><ul><li>클래스 안에 다른 클래스를 선언할 수 있음</li><li>자바와의 차이는 <strong>중첩 클래스</strong>는 명시적으로 요청하지 않는 한 바깥쪽 클래스 인스턴스에 대한 접근 권한이 없다는 점</li></ul><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx" style="color:#F8F8F2;background-color:#282A36"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">interface State: Serializable</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">interface View {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  fun getCurrentState(): State</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  fun restoreState(state: State)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><ul><li><code>Button</code> 클래스 상태를 저장하는 클래스는 <code>Button</code> 클래스 내부에 선언</li></ul><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#F8F8F2;background-color:#282A36"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">public class Button implements View {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  @Override</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  public State getCurrentState() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    return new ButtonState()</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  @Override</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  public void restoreState(State state) { ... }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  </span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  public class ButtonState implements State {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    * ButtonState 클래스 정의</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><ul><li><code>ButtonState</code>를 직렬화하면 <code>NotSerializableException</code> 오류 발생<ul><li>자바에서 클래스 안에 정의한 클래스는 내부 클래스로 취급</li><li>바깥쪽 Button 클래스에 대한 참조를 묵시적으로 포함</li><li>그 참조로 인해 <code>ButtonState</code>은 직렬화할 수 없음</li></ul></li><li>자바에선 이 문제를 해결하기 위해 <code>static</code>으로 선언해야함</li></ul><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx" style="color:#F8F8F2;background-color:#282A36"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">class Button: View {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  override fun getCurrentState(): State = ButtonState()</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  override fun restoreState(state: State) { ... }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  class ButtonState: State {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    * ButtonState 클래스 정의</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><ul><li>코틀린 중첩 클래스에 아무런 변경자가 없으면 자바 static 중첩 클래스와 동일</li><li>내부 클래스로 변경하여 바깥쪽 참조를 포함하고 싶으면 <code>inner</code> 변경자를 붙이면 됨</li></ul><p><img loading="lazy" src="https://user-images.githubusercontent.com/4207192/164894105-13d0c1d8-a585-4173-8fe9-3becca3ab335.png" alt="image" class="img_E7b_"></p><ul><li>내부에서 바깥쪽 클래스를 참조하기 위해서는 <code>this@Outer</code>를 통해 참조할 수 있음</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="봉인된-클래스-클래스-계층-정의-시-계층-확장-제한">봉인된 클래스: 클래스 계층 정의 시 계층 확장 제한<a class="hash-link" href="#봉인된-클래스-클래스-계층-정의-시-계층-확장-제한" title="Direct link to heading">​</a></h3><ul><li><a href="https://kimgs0725.github.io/til/docs/programming/kotlin-in-action/ch2#%EC%8A%A4%EB%A7%88%ED%8A%B8-%EC%BA%90%EC%8A%A4%ED%8A%B8-%ED%83%80%EC%9E%85-%EA%B2%80%EC%82%AC%EC%99%80-%ED%83%80%EC%9E%85-%EC%BA%90%EC%8A%A4%ED%8A%B8%EB%A5%BC-%EC%A1%B0%ED%95%A9" target="_blank" rel="noopener noreferrer">2.3.5절에 있는 클래스 계층</a>을 다시 가져와서</li></ul><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx" style="color:#F8F8F2;background-color:#282A36"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">interface Expr</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">class Num(val value: Int): Expr</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">class Sum(val left: Expr, val right: Expr): Expr</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><ul><li>when 식에서 Num과 Sum이 아닌 경우 else 분기를 넣어야 함</li></ul><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx" style="color:#F8F8F2;background-color:#282A36"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fun eval(e: Expr) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  when (e) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    is Num -&gt; e.val</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    is Sum -&gt; eval(e.right) + eval(e.left)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    else -&gt;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">      throw IllegalArgumentException(&quot;Unknown expression&quot;)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><ul><li>코틀린은 이 문제를 해결하기 위해 <code>sealed</code> 클래스를 제공함<ul><li><code>sealed</code>는 상위 클래스를 상혹한 하위 클래스 정의를 제한시킬 수 있음</li></ul></li></ul><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx" style="color:#F8F8F2;background-color:#282A36"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">sealed class Expr {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  class Num(val value: Int): Expr()</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  class Sum(val left: Expr, val right: Expr): Expr()</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fun eval(e: Expr) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  when (e) {  // when식에서 모든 하위 클래스를 검사하므로 별도의 else 분기가 없어도 됨</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    is Expr.Num -&gt; e.val</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    is Expr.Sum -&gt; eval(e.right) + eval(e.left)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="2-뻔하지-않은-생성자와-프로퍼티를-갖는-클래스-선언">2. 뻔하지 않은 생성자와 프로퍼티를 갖는 클래스 선언<a class="hash-link" href="#2-뻔하지-않은-생성자와-프로퍼티를-갖는-클래스-선언" title="Direct link to heading">​</a></h2><ul><li>코틀린에선 생성자를 주 생성자와 부 생성자로 구분<ul><li>초기화 블록을 통해 초기화 로직을 추가</li></ul></li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="클래스-초기화-주-생성자와-초기화-블록">클래스 초기화: 주 생성자와 초기화 블록<a class="hash-link" href="#클래스-초기화-주-생성자와-초기화-블록" title="Direct link to heading">​</a></h3><ul><li>클래스 이름 뒤에 오는 괄호로 둘러싸인 코드를 <strong>주 생성자</strong>라고 함</li></ul><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx" style="color:#F8F8F2;background-color:#282A36"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">class User constructro (_nickname: String) {  // 파라미터가 하나만 있는 주 생성자</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  val nickname: String</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  init {    // 초기화 블록</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    nickname = _nickname</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><ul><li><code>constructor</code>는 주 생성자와 부 생성자를 정의내릴 때 사용</li><li><code>init</code>은 초기화 블록을 시작<ul><li>클래스 안에 여러 초기화 블록을 선언할 수 있음</li></ul></li><li>주 생성자 앞에 별다른 애노테이션이나 가시성 변경자가 없다면 <code>constructor</code>는 생략 가능</li></ul><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx" style="color:#F8F8F2;background-color:#282A36"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">class User(_nickname: String) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  val nickname = _nickname</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><ul><li>주 생성자 파라미터 이름 앞에 <code>val</code>을 추가하면 프로퍼티 정의와 초기화를 간략화할 수 있음</li></ul><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx" style="color:#F8F8F2;background-color:#282A36"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">class User(val nickname: String)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><ul><li>함수와 마찬가지로 디폴트 파라미터를 정의할 수 있음</li><li>인스턴스 생성은 <code>new</code> 키워드 없이 생성해야 함</li><li>상속 시, 부모 클래스로 넘겨야할 파라미터가 있다면 부모클래스 이름 뒤에 괄호치고 생성인자를 넘길 수 있음</li></ul><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx" style="color:#F8F8F2;background-color:#282A36"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">open class User(val nickname: String) { ... }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">class TwitterUser(nickname: String): User(nickname) { ... }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><ul><li>부모 클래스에 파라미터가 없더라도, 빈 괄호는 표시해야함<ul><li>단, 인터페이스의 경우 인스턴스로 생성될 수 없기에 괄호는 표시하지 않음</li></ul></li><li>클래스 외부에서 인스턴스화하지 못하게 막고 싶으면 모든 생성자를 private으로 변경하면 됨</li></ul><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx" style="color:#F8F8F2;background-color:#282A36"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">class Secretive private constructor() { ... }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="부-생성자-상위-클래스를-다른-방식으로-초기화">부 생성자: 상위 클래스를 다른 방식으로 초기화<a class="hash-link" href="#부-생성자-상위-클래스를-다른-방식으로-초기화" title="Direct link to heading">​</a></h3><ul><li>생성자가 많이 필요한 자바와 달리, 코틀린에선 디폴트 파라미터와 이름 붙은 인자 문법으로 오버로드를 해결할 수 있음</li><li>그럼에도 생성자가 여럿 필요한 경우<ul><li>프레임워크 클래스를 확장해야 하는데, 여러 가지 방법으로 인스턴스를 초기화할 수 있게 다양한 생성자를 지원해야하는 경우</li></ul></li></ul><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx" style="color:#F8F8F2;background-color:#282A36"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">open class View {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  constructor(ctx: Context) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  constructor(ctx: Context, attr: AttributeSet) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><ul><li>클래스를 확장하면서 똑같이 부 생성자를 정의할 수 있음</li></ul><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx" style="color:#F8F8F2;background-color:#282A36"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">class MyButton : View {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  constructor(ctx: Context) : super(ctx) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  constructor(ctx: Context, attr: AttributeSet) : super(ctx, attr) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><ul><li><code>this</code>를 통해 클래스 자신의 다른 생성자 호출 가능</li></ul><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx" style="color:#F8F8F2;background-color:#282A36"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">class MyButton : View {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  constructor(ctx: Context) : this(ctx, MY_STYLE) { // 이 클래스의 다른 생성자에게 위임</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  constructor(ctx: Context, attr: AttributeSet) : super(ctx, attr) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><ul><li>부 생성자가 필요한 이유는 자바 상호운용성 때문</li><li>그리고 다른 생성 방법이 여럿 존재하는 경우에도 부 생성자가 필요</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="인터페이스에-선언된-프로퍼터-구현">인터페이스에 선언된 프로퍼터 구현<a class="hash-link" href="#인터페이스에-선언된-프로퍼터-구현" title="Direct link to heading">​</a></h3><ul><li>인터페이스에 추상 프로퍼티 선언을 넣을 수 있음</li></ul><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx" style="color:#F8F8F2;background-color:#282A36"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">interface User {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  val nickname: String</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><ul><li>이는 인터페이스를 구현하는 클래스에서 추상 프로퍼티를 구현해야함</li><li>그럼 클래스에서 이 프로퍼티를 어떻게 구현해야할까?</li></ul><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx" style="color:#F8F8F2;background-color:#282A36"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">class PrivateUser(override val nickname: String): User  // 주 생성자에 있는 프로퍼티</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">class SubscribingUser(val email: String): User {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  override val nickname: String</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    get() = email.substringBefore(&#x27;@&#x27;)    // 커스텀 게터</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">class FacebookUser(val accountId: Int): User {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  override val nickname = getFacebookName(accountId)    // 프로퍼티 초기화 식</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><ul><li>인터페이스에는 추상 프로퍼티뿐만 아니라 게터와 세터가 잇는 프로퍼티를 선언할 수 있음<ul><li>단, 게터, 세터를 뒷받침할 필드를 참조할 수 없음</li></ul></li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="게터와-세터에서-뒷받침하는-필드에-접근">게터와 세터에서 뒷받침하는 필드에 접근<a class="hash-link" href="#게터와-세터에서-뒷받침하는-필드에-접근" title="Direct link to heading">​</a></h3><ul><li>값을 저장하는 동시에 로직을 실행할 수 있게 하기 위해서는 접근자 안에서 프로퍼티를 뒷받침하는 필드에 접근할 수 있어야 하ㅣㅁ</li><li>프로퍼티에 저장된 값을 로그로 남기려는 경우를 생각</li></ul><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx" style="color:#F8F8F2;background-color:#282A36"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">class User(val name: String) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var address: String = &quot;unspecified&quot;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    set(value: String) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">      println(&quot;&quot;&quot;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        Address was changed for $name:</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        &quot;$field&quot; -&gt; &quot;$value&quot;.&quot;&quot;&quot;.trimIndent())</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">      )</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">      field = value</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><ul><li>접근자 본문에서 <code>field</code>라는 특별한 식별자를 통해 뒷받침하는 필드에 접근할 수 있음</li><li>컴파일러는 디폴트 접근자 구현을 사용하건 직접 게터나 세터를 정의하건 관계없이 게터나 세터에서 <code>field</code>를 사용하는 프로퍼티에 대해 뒷받침하는 필드를 생성함</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="접근자의-가시성-변경">접근자의 가시성 변경<a class="hash-link" href="#접근자의-가시성-변경" title="Direct link to heading">​</a></h3><ul><li>기본적으로는 프로퍼티의 가시성과 같음</li><li>원한다면 <code>get</code>이나 <code>set</code> 앞에 가시성 변경자를 추가해서 가시성을 변경할 수 있음</li></ul><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx" style="color:#F8F8F2;background-color:#282A36"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">class LengthCounter {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var counter: Int = 0</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    private set</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  </span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  fun addWord(word: String) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    counter += word.length</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="3-컴파일러가-생성한-메소드-데이터-클래스와-클래스-위임">3. 컴파일러가 생성한 메소드: 데이터 클래스와 클래스 위임<a class="hash-link" href="#3-컴파일러가-생성한-메소드-데이터-클래스와-클래스-위임" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_mojV" id="모든-클래스가-정의해야하는-메소드">모든 클래스가 정의해야하는 메소드<a class="hash-link" href="#모든-클래스가-정의해야하는-메소드" title="Direct link to heading">​</a></h3><ul><li>코틀린도 <code>toString</code>, <code>equals</code>, <code>hashCode</code>등을 오버라이드 해야함</li><li>다음 클래스가 있다고 가정</li></ul><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx" style="color:#F8F8F2;background-color:#282A36"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">class Client(val name: String, val postalCode: Int)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h4 class="anchor anchorWithStickyNavbar_mojV" id="문자열-표현-tostring">문자열 표현: toString()<a class="hash-link" href="#문자열-표현-tostring" title="Direct link to heading">​</a></h4><ul><li>기본으로 제공되는 문자열 표현은 <code>Client@5e9f23b4</code>와 같이 표현</li><li>오버라이드를 통해 유용한 정보를 뿌리는 <code>toString</code>으로 재정의할 수 있음</li></ul><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx" style="color:#F8F8F2;background-color:#282A36"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">class Client(val name: String, val postalCode: Int) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  override fun toString() = &quot;Client(name=$name, postalCode=$postalCode)&quot;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h4 class="anchor anchorWithStickyNavbar_mojV" id="객체의-동등성-equals">객체의 동등성: equals()<a class="hash-link" href="#객체의-동등성-equals" title="Direct link to heading">​</a></h4><ul><li>때때로 서로 다른 객체가 동일한 데이터를 포함한 경우, 그 둘을 동등한 객체로 간주해야하는 경우도 존재<ul><li>동등성 연산에는 <code>==</code>을 샤용</li></ul></li><li>위 요구사항을 만족시키기 위해 <code>equals</code>을 구현</li></ul><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx" style="color:#F8F8F2;background-color:#282A36"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">class Client(val name: String, val postalCode: Int) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  override fun equals(other: Any?): Boolean {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    if (other == null || other !is Client) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">      return false</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    return name == other.name &amp;&amp; postalCode == other.postalCode</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  override fun toString() = &quot;Client(name=$name, postalCode=$postalCode)&quot;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h4 class="anchor anchorWithStickyNavbar_mojV" id="해시-컨테이너-hashcode">해시 컨테이너: hashCode()<a class="hash-link" href="#해시-컨테이너-hashcode" title="Direct link to heading">​</a></h4><ul><li><p><code>equals</code>를 오버라이드할 때 반드시 <code>hashCode</code>도 오버라이드해야 함</p></li><li><p>JVM 언어에선 <code>hashCode</code>가 지켜야하는 제약이 존재</p><blockquote><p>equals()가 true를 반환하는 두 객체는 반드시 같은 hashCode()를 반환해야한다</p></blockquote></li></ul><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx" style="color:#F8F8F2;background-color:#282A36"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">class Client(val name: String, val postalCode: Int) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  override fun hashCode(): Int = name.hashCode() * 31 + postalCode</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  override fun equals(other: Any?): Boolean {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    if (other == null || other !is Client) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">      return false</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    return name == other.name &amp;&amp; postalCode == other.postalCode</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  override fun toString() = &quot;Client(name=$name, postalCode=$postalCode)&quot;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="데이터-클래스-모든-클래스가-정의해야-하는-메소드-자동-생성">데이터 클래스: 모든 클래스가 정의해야 하는 메소드 자동 생성<a class="hash-link" href="#데이터-클래스-모든-클래스가-정의해야-하는-메소드-자동-생성" title="Direct link to heading">​</a></h3><ul><li><code>data</code> 라는 변경자를 클래스 앞에 붙이면 컴파일러가 자동으로 <code>toString()</code>, <code>equals()</code>, <code>hashCode()</code>을 만들어줌</li></ul><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx" style="color:#F8F8F2;background-color:#282A36"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">data class Client(val name: String, val postalCode: Int)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><ul><li><code>data</code> 클래스는 다음 메소드를 포함<ul><li>인스턴스가 비교를 위한 <code>equals</code></li><li>HashMap과 같은 해시 기반 컨테이너에서 키로 사용할 수 있는 <code>hashCode</code></li><li>클래스의 각 필드를 선언 순서대로 표시하여 문자열로 표현하는 <code>toString</code></li></ul></li><li>위 메소드 말고도 <code>copy()</code> 메소드도 자동 구현해줌</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="클래스-위임-by-키워드-사용">클래스 위임: by 키워드 사용<a class="hash-link" href="#클래스-위임-by-키워드-사용" title="Direct link to heading">​</a></h3><ul><li>대규모 설계 시, 구현 상속은 시스템을 취약하게 만듦</li><li>코틀린에선 기본적으로 클래스를 <code>final</code>로 두어 함부로 상속하지 못하게 함</li><li>대신 상속을 허용하지 않는 클래스에서 새로운 동작을 추가하려 할 때, 데코레이터 패턴을 사용<ul><li>새로운 클래스에 기능을 정의하고, 기존 클래스는 새로운 클래스로 메소드 요청을 전달</li><li>하지만, 새로운 클래스를 만들어야 하기 때문에 복잡</li></ul></li></ul><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx" style="color:#F8F8F2;background-color:#282A36"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">class DelegatingCollection&lt;T&gt;: Collection&lt;T&gt; {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  private val innerList = arrayListOf&lt;T&gt;()</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  override val size: Int get() = innerSize.size</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  override fun isEmpty(): Boolean = innerList.isEmpty()</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  override fun contains(element: T): Boolean = innerList.contains(element)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  override fun iterator(): Iterator&lt;T&gt; = innerList.iterator()</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  override fun containsAll(elements: Collection&lt;T&gt;): Boolean = innerList.containsAll(elements)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><ul><li>코틀린에선 인터페이스를 구현할 때, <code>by</code> 키워드를 통해 인터페이스에 대한 구현을 다른 객체에 위임 중이란 것을 명시할 수 있음</li><li>메소드 중 일부 동작을 변경하고 싶은 메소드만 오버라이드하면 됨</li></ul><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx" style="color:#F8F8F2;background-color:#282A36"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">class CountingSet&lt;T&gt;(</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    private val innerSet: MutableCollection&lt;T&gt; = HashSet&lt;T&gt;()</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">) : MutableCollection&lt;T&gt; by innerSet {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    var objectsAdded = 0</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    override fun add(element: T): Boolean {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        objectsAdded++</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        return innerSet.add(element)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    override fun addAll(elements: Collection&lt;T&gt;): Boolean {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        objectsAdded += elements.size</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        return innerSet.addAll(elements)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">&gt;&gt;&gt; val cset = CountingSet&lt;Int&gt;()</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">&gt;&gt;&gt; cset.addAll(listOf(1, 1, 2))</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">&gt;&gt;&gt; println(&quot;${cset.objectsAdded} objects were added, ${cset.size} remain&quot;)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">3 objects were added, 2 remain</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="4-object-키워드-클래스-선언과-인스턴스-생성">4. object 키워드: 클래스 선언과 인스턴스 생성<a class="hash-link" href="#4-object-키워드-클래스-선언과-인스턴스-생성" title="Direct link to heading">​</a></h2><ul><li><code>object</code>는 선언과 동시에 인스턴스를 생성함</li><li><code>object</code>를 쓰는 케이스는 다음과 같음<ul><li><strong>객체 선언</strong>은 싱글턴을 정의하는 방법 중 하나</li><li><strong>동반 객체</strong>는 인스턴스 메소드는 아니지만 어떤 클래스와 관련있는 메소드와 팩토리 메소드를 담을 때 쓰임</li><li>객체 식은 자바의 <strong>무명 내부 객체</strong> 대신 쓰임</li></ul></li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="객체-선언-싱글턴-쉽게-만들기">객체 선언: 싱글턴 쉽게 만들기<a class="hash-link" href="#객체-선언-싱글턴-쉽게-만들기" title="Direct link to heading">​</a></h3><ul><li>인스턴스가 하나만 필요한 클래스를 만들기 위해 <a href="https://ko.wikipedia.org/wiki/%EC%8B%B1%EA%B8%80%ED%84%B4_%ED%8C%A8%ED%84%B4" target="_blank" rel="noopener noreferrer">싱글턴 패턴</a>을 자주 이용함</li><li>코틀린에선 <strong>객체 선언</strong> 기능을 이용해 싱글턴을 언어상에서 기본 지원</li></ul><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx" style="color:#F8F8F2;background-color:#282A36"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">object Payroll {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  val allEmployees = arrayListOf&lt;Person&gt;()</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  fun calculateSalary() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    for (person in allEmployees) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">      ...</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">&gt;&gt;&gt; Payroll.allEmployees.add(Person(...))</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">&gt;&gt;&gt; Payroll.calculateSalary()</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><ul><li>객체 선언 뒤에 .을 붙여 객체에 속한 프로퍼티나 메소드에 접근</li><li>객체 선언도 클래스나 인스턴스를 상속할 수 있음</li></ul><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx" style="color:#F8F8F2;background-color:#282A36"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">object CaseInsensitiveFileComparator : Comparator&lt;File&gt; {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  override fun compare(file1: File, file2: File): Int {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    return file1.path.compareTo(file2.path, ignoreCase = true)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><blockquote><p><strong>싱글턴과 의존관계 주입</strong></p><p>싱글턴 패턴과 마찬가지 이유로 대규모 소프트웨어 시스템에서는 객체 선언이 항상 적합하지는 않다.
의존 관계가 별로 많지 않은 소규모 소프트웨어에서는 싱글턴이나 객체 선언이 유용하지만,
시스템을 구현하는 다양한 구성 요소와 상호작용하는 대규모 컴포넌트에는 싱글턴이 적합하지 않다.
이유는 객체 생성을 제어할 방법이 없고 생성자 파라미터를 지정할 수 없어서이다.</p><p>생성을 제어할 수 없고 생성자 파라미터를 지정할 수 없으므로 단위 테스트를 하거나 소프트웨어
시스템의 설정이 달라질 때 객체를 대체하거나 객체를 의존관계를 바꿀 수 없다.
따라서 그런 기능이 필요하다면 자바와 마찬가지로 의존관계 주입 프레임워크와 코틀린 클래스를 함께 사용해야한다.</p></blockquote><ul><li>클래스 안에 <code>object</code>를 선언할 수 있음<ul><li>이 역시 한번만 생성됨</li></ul></li></ul><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx" style="color:#F8F8F2;background-color:#282A36"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">data class Person(val name: String) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  object NameComparator : Comparator&lt;Person&gt; {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    override fun compare(p1: Person, p2: Person): Int = p1.name.compareTo(p2.name)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">&gt;&gt;&gt; val persons = listOf(Person(&quot;Bob&quot;), Person(&quot;Alice&quot;))</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">&gt;&gt;&gt; println(persons.sortedWith(Person.NameComparator))</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">[Person(name=Alice), Person(name=Bob)]</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="동반-객체-팩토리-메소드와-정적-멤버가-들어갈-장소">동반 객체: 팩토리 메소드와 정적 멤버가 들어갈 장소<a class="hash-link" href="#동반-객체-팩토리-메소드와-정적-멤버가-들어갈-장소" title="Direct link to heading">​</a></h3><ul><li><p>코틀린 클래스에선 <code>static</code>을 지원하지 않기 때문에 패키지 수준의 <strong>최상위 함수</strong>와 <strong>객체 선언</strong>을 주로 활용</p><ul><li>하지만 최상위 함수는 객체 내 private 멤버에 접근할 수 없음</li></ul></li><li><p>클래스의 인스턴스와 관계없이 호출, but 클래스 내부 정보에 접근해야하는 함수가 필요 -&gt; 중첩된 객체 선언을 멤버 함수로 정의</p><ul><li>팩토리 메소드를 예로 들 수 있음</li></ul><p><img loading="lazy" src="https://user-images.githubusercontent.com/4207192/165403569-04326497-3675-4d97-b4ae-56dcf7cf0c48.png" alt="image" class="img_E7b_"></p></li><li><p><code>companion</code> 키워드를 통해 클래스의 동반 객체를 만들 수 있음</p></li><li><p>동반 객체는 자신을 둘러싼 클래스의 모든 <code>private</code> 멤버에 접근 가능</p></li></ul><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx" style="color:#F8F8F2;background-color:#282A36"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">// without 동반 객체</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">class User {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  val nickname: String</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  constructor(email: String) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    nickname = email.substringBefore(&#x27;@&#x27;)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  constructor(facebookAccountId: Int) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    nickname = getFacebookName(facebookAccountId)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// with 동반 객체</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">class User private constructor(val nickname: String) {  // 주 생성자를 비공개로 만듦</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  companion object {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    fun newSubscribingUser(email: String) =</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">      User(email.substringBefore(&#x27;@&#x27;))</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    fun newFacebookUser(accountId: Int) =</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">      User(getFacebookName(accountId))</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><ul><li>다만 클래스를 확장해야하는 경우, 하위 클래스에서 오버라이드 할 수 없으므로 여러 생성자를 사용하는게 좋음</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="동반-객체를-일반-객체처럼-사용">동반 객체를 일반 객체처럼 사용<a class="hash-link" href="#동반-객체를-일반-객체처럼-사용" title="Direct link to heading">​</a></h3><ul><li>동반 객체도 일반 객체<ul><li>일반 객체처럼 이름을 붙이거나</li><li>인터페이스를 상속</li><li>확장 함수와 프로퍼티를 정의할 수 있음</li></ul></li></ul><h4 class="anchor anchorWithStickyNavbar_mojV" id="동반-객체에-이름-부여">동반 객체에 이름 부여<a class="hash-link" href="#동반-객체에-이름-부여" title="Direct link to heading">​</a></h4><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx" style="color:#F8F8F2;background-color:#282A36"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">class Person(val name: String) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  companion object Loader {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    fun fromJSON(jsonText: String): Person = ...</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">&gt;&gt;&gt; Person.Loader.fromJSON(...)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">&gt;&gt;&gt; Person.fromJSON(...)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h4 class="anchor anchorWithStickyNavbar_mojV" id="동반-객체에서-인터페이스-구현">동반 객체에서 인터페이스 구현<a class="hash-link" href="#동반-객체에서-인터페이스-구현" title="Direct link to heading">​</a></h4><ul><li><code>object</code>처럼 인터페이스를 구현할 수 있음</li></ul><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx" style="color:#F8F8F2;background-color:#282A36"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">interface JSONFactory&lt;T&gt; {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  fun fromJSON(jsonText: String): T</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">class Person(val name: String) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  companion object : JSONFactory&lt;Person&gt; {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    override fun fromJSON(jsonText: String): Person = ...</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h4 class="anchor anchorWithStickyNavbar_mojV" id="동반-객체-확장">동반 객체 확장<a class="hash-link" href="#동반-객체-확장" title="Direct link to heading">​</a></h4><ul><li>동반 객체 안에 함수를 정의함으로써 클래스에 대해 호출할 수 있는 확장함수를 만들 수 있음<ul><li><code>C</code>라는 클래스 안에 <code>C.Companion</code> 동반 객체 안에 <code>func</code>를 정의하면 외부에서 <code>func</code>를 <code>C.func</code>로 호출할 수 있음</li></ul></li></ul><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx" style="color:#F8F8F2;background-color:#282A36"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">class Person(val firstName:  String, val lastName: String) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  companion object {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fun Person.Companion.fromJSON(json: String): Person {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  ...</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">val p = Person.fromJSON(json)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><ul><li>여기서 동반객체에 대한 확장 함수를 작성하려면, 원래 클래스에 동반 객체를 꼭 선언해야함(빈 내용이라도)</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="객체-식-무명-내부-클래스를-다른-방식으로-작성">객체 식: 무명 내부 클래스를 다른 방식으로 작성<a class="hash-link" href="#객체-식-무명-내부-클래스를-다른-방식으로-작성" title="Direct link to heading">​</a></h3><ul><li>무명 객체를 정의할 때에도 <code>object</code> 키워드를 씀</li></ul><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx" style="color:#F8F8F2;background-color:#282A36"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain">// 무명 클래스로 이벤트 리스너 구현</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">window.addMouseListener(</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  object: MouseAdapter() {   // MouseAdapter를 확장하는 무명 객체 선언</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    override fun mouseClicked(e: MouseEvent) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">      ...</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    override fun mouseEntered(e: MouseEvent) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">      ...</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><ul><li>객체 선언과 비슷하지만, 이름이 없다는 것이 특징</li><li>객체 선언과 달리 무명 객체는 싱글턴이 아님. 식이 쓰일 때마다 인스턴스가 생성</li><li>무명 객체 식 안에 로컬 변수 접근 가능</li></ul><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx" style="color:#F8F8F2;background-color:#282A36"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fun countClicks(window: Window) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  var clickCount = 0</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  window.addMouseListener(object: MouseAdapter() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    override fun mouseClicked(e: MouseEvent) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">      clickCount++</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  })</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="5-요약">5. 요약<a class="hash-link" href="#5-요약" title="Direct link to heading">​</a></h2><ul><li>코틀린 인터페이스는 디폴트 메소드와 프로퍼티를 포함</li><li>모든 코틀린 선언은 기본 <code>public final</code>임</li><li><code>final</code>을 안 붙이려면 <code>open</code> 키워드 사용</li><li><code>internal</code>은 같은 모듈에서만 접근 가능</li><li>중첩 클래스는 내부 클래스가 아님. <code>inner</code> 키워드를 통해 중첩 클래스 내에서 바깥 클래스에 대한 참조 가능</li><li><code>sealed</code> 클래스를 사용하는 클래스를 정의하려면 반드시 부모 클래스 정의 안에 중첩 클래스로 정의</li><li>초기화 블록과 부 생성자를 통해 인스턴스를 유연하게 초기화</li><li><code>data class</code>를 사용하면 컴파일러가 <code>equals</code>, <code>hashCode</code>, <code>toString</code>, <code>copy</code> 등의 메소드를 자동으로 생성</li><li>클래스 위임을 사용해 위임에 작성되는 보일러 플레이트 코드들을 예방</li><li>객체 선언을 통해 싱글턴 클래스를 정의</li></ul></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/wondsn/til/edit/main/docs/programming/kotlin-in-action/ch4.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_dcUD" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_foO9"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/til/docs/programming/kotlin-in-action/ch3"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">3. 함수의 정의와 호출</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/til/docs/programming/kotlin-in-action/ch5"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">5. 람다로 프로그래밍</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_cNA8 thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#1-클래스-계층-정의" class="table-of-contents__link toc-highlight">1. 클래스 계층 정의</a><ul><li><a href="#코틀린-인터페이스" class="table-of-contents__link toc-highlight">코틀린 인터페이스</a></li><li><a href="#open-final-abstract-변경자-기본적으로-final" class="table-of-contents__link toc-highlight">open, final, abstract 변경자: 기본적으로 final</a></li><li><a href="#가시성-변경자-기본적으로-공개" class="table-of-contents__link toc-highlight">가시성 변경자: 기본적으로 공개</a></li><li><a href="#내부-클래스와-중첩된-클래스-기본적으로-중첩-클래스" class="table-of-contents__link toc-highlight">내부 클래스와 중첩된 클래스: 기본적으로 중첩 클래스</a></li><li><a href="#봉인된-클래스-클래스-계층-정의-시-계층-확장-제한" class="table-of-contents__link toc-highlight">봉인된 클래스: 클래스 계층 정의 시 계층 확장 제한</a></li></ul></li><li><a href="#2-뻔하지-않은-생성자와-프로퍼티를-갖는-클래스-선언" class="table-of-contents__link toc-highlight">2. 뻔하지 않은 생성자와 프로퍼티를 갖는 클래스 선언</a><ul><li><a href="#클래스-초기화-주-생성자와-초기화-블록" class="table-of-contents__link toc-highlight">클래스 초기화: 주 생성자와 초기화 블록</a></li><li><a href="#부-생성자-상위-클래스를-다른-방식으로-초기화" class="table-of-contents__link toc-highlight">부 생성자: 상위 클래스를 다른 방식으로 초기화</a></li><li><a href="#인터페이스에-선언된-프로퍼터-구현" class="table-of-contents__link toc-highlight">인터페이스에 선언된 프로퍼터 구현</a></li><li><a href="#게터와-세터에서-뒷받침하는-필드에-접근" class="table-of-contents__link toc-highlight">게터와 세터에서 뒷받침하는 필드에 접근</a></li><li><a href="#접근자의-가시성-변경" class="table-of-contents__link toc-highlight">접근자의 가시성 변경</a></li></ul></li><li><a href="#3-컴파일러가-생성한-메소드-데이터-클래스와-클래스-위임" class="table-of-contents__link toc-highlight">3. 컴파일러가 생성한 메소드: 데이터 클래스와 클래스 위임</a><ul><li><a href="#모든-클래스가-정의해야하는-메소드" class="table-of-contents__link toc-highlight">모든 클래스가 정의해야하는 메소드</a></li><li><a href="#데이터-클래스-모든-클래스가-정의해야-하는-메소드-자동-생성" class="table-of-contents__link toc-highlight">데이터 클래스: 모든 클래스가 정의해야 하는 메소드 자동 생성</a></li><li><a href="#클래스-위임-by-키워드-사용" class="table-of-contents__link toc-highlight">클래스 위임: by 키워드 사용</a></li></ul></li><li><a href="#4-object-키워드-클래스-선언과-인스턴스-생성" class="table-of-contents__link toc-highlight">4. object 키워드: 클래스 선언과 인스턴스 생성</a><ul><li><a href="#객체-선언-싱글턴-쉽게-만들기" class="table-of-contents__link toc-highlight">객체 선언: 싱글턴 쉽게 만들기</a></li><li><a href="#동반-객체-팩토리-메소드와-정적-멤버가-들어갈-장소" class="table-of-contents__link toc-highlight">동반 객체: 팩토리 메소드와 정적 멤버가 들어갈 장소</a></li><li><a href="#동반-객체를-일반-객체처럼-사용" class="table-of-contents__link toc-highlight">동반 객체를 일반 객체처럼 사용</a></li><li><a href="#객체-식-무명-내부-클래스를-다른-방식으로-작성" class="table-of-contents__link toc-highlight">객체 식: 무명 내부 클래스를 다른 방식으로 작성</a></li></ul></li><li><a href="#5-요약" class="table-of-contents__link toc-highlight">5. 요약</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/til/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Profile</div><ul class="footer__items"><li class="footer__item"><a href="https://www.linkedin.com/in/gyeong-soo-kim-3b603412a/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Linkedin<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a href="http://wondsn.github.io" target="_blank" rel="noopener noreferrer" class="footer__link-item">Blog<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://github.com/wondsn" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 Gyeongsoo's Study, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/til/assets/js/runtime~main.bfa5a1d6.js"></script>
<script src="/til/assets/js/main.641e2650.js"></script>
</body>
</html>